//+------------------------------------------------------------------+
//| üî• RSI PrimeBot v2.40 - ALINHAMENTO VERTICAL PERFEITO          |
//| SOLU√á√ÉO: Usar MESMAS barras para tra√ßar pre√ßo e RSI            |
//| Primeiro encontra extremos de PRE√áO, depois usa mesmas barras  |
//+------------------------------------------------------------------+
//|               Divergence RSI volume e for√ßa PrimeBot            |
//|  ULTRA RESPONSIVO + SEPARA√á√ÉO VISUAL + VOLUME ENHANCED          |
//|                     Copyright PrimeBot 2025                      |
//|                  https://www.primebotportfolio.com.br/           |
//|------------------------------------------------------------------|
//| v2.40 - üéØ ALINHAMENTO VERTICAL PERFEITO DOS TRA√áADOS          |
//| üîß BASE: v2.38 mantida 100% intacta com todas fun√ß√µes          |
//| üî• CORRE√á√ÉO: Tra√ßados sempre nas MESMAS barras (alinhados)      |
//| üî• MELHORIA: FindAlignedExtremes() garante alinhamento          |
//| üî• MANTIDO: Todos os inputs originais sem altera√ß√£o             |
//| üî• MANTIDO: Todas as valida√ß√µes e filtros rigorosos             |
//| üî• MANTIDO: Sistema de qualidade e score original               |
//| ‚ö° OBJETIVO: Linhas perfeitamente alinhadas verticalmente       |
//+------------------------------------------------------------------+
#property copyright "Copyright PrimeBot 2025"
#property link      "https://www.primebotportfolio.com.br/"
#property version   "2.40"
#property description "Divergence RSI PrimeBot v2.40 - Alinhamento Vertical Perfeito"
#property indicator_separate_window
#property indicator_buffers 14
#property indicator_plots   14
#property indicator_minimum 0
#property indicator_maximum 100

//--- Plots ORIGINAIS (mantidos)
#property indicator_label1  "RSI"
#property indicator_type1   DRAW_LINE
#property indicator_color1  clrDodgerBlue
#property indicator_style1  STYLE_SOLID
#property indicator_width1  2
#property indicator_label2  "Buy Signal"
#property indicator_type2   DRAW_ARROW
#property indicator_color2  clrPaleGreen
#property indicator_style2  STYLE_SOLID
#property indicator_width2  2
#property indicator_label3  "Sell Signal"
#property indicator_type3   DRAW_ARROW
#property indicator_color3  clrLightSalmon
#property indicator_style3  STYLE_SOLID
#property indicator_width3  2
#property indicator_label4  "RSI Divergence Line"
#property indicator_type4   DRAW_NONE
#property indicator_color4  clrYellow
#property indicator_style4  STYLE_SOLID
#property indicator_width4  3
#property indicator_label5  "Volume"
#property indicator_type5   DRAW_HISTOGRAM
#property indicator_color5  clrGray
#property indicator_style5  STYLE_SOLID
#property indicator_width5  2
#property indicator_label6  "Volume Average"
#property indicator_type6   DRAW_LINE
#property indicator_color6  clrYellow
#property indicator_style6  STYLE_SOLID
#property indicator_width6  1
#property indicator_label7  "Volume Buy Confirm"
#property indicator_type7   DRAW_ARROW
#property indicator_color7  clrGold
#property indicator_style7  STYLE_SOLID
#property indicator_width7  6
#property indicator_label8  "Volume Sell Confirm"
#property indicator_type8   DRAW_ARROW
#property indicator_color8  clrMagenta
#property indicator_style8  STYLE_SOLID
#property indicator_width8  6
#property indicator_label9  "Divider Line"
#property indicator_type9   DRAW_LINE
#property indicator_color9  clrDimGray
#property indicator_style9  STYLE_DOT
#property indicator_width9  1
#property indicator_label10 "Buy Signal Confirmed"
#property indicator_type10  DRAW_NONE
#property indicator_label11 "Sell Signal Confirmed"
#property indicator_type11  DRAW_NONE
#property indicator_label12 "Raw RSI Data"
#property indicator_type12  DRAW_NONE
#property indicator_label13 "Buy Circle Backtest"
#property indicator_type13  DRAW_ARROW
#property indicator_color13 clrGold
#property indicator_width13 5
#property indicator_label14 "Sell Circle Backtest"
#property indicator_type14  DRAW_ARROW
#property indicator_color14 clrMagenta
#property indicator_width14 5

//+------------------------------------------------------------------+
//| Constantes de Escala e Visual - DEFINIDAS ANTES DE USAR         |
//+------------------------------------------------------------------+
#define RSI_ZONE_MIN 30.0       // RSI regi√£o visual m√≠nima
#define RSI_ZONE_MAX 100.0      // RSI regi√£o visual m√°xima  
#define VOLUME_ZONE_MIN 0.0     // Volume regi√£o visual m√≠nima
#define VOLUME_ZONE_MAX 25.0    // Volume regi√£o visual m√°xima
#define DIVIDER_LINE 28.0       // Linha divis√≥ria entre Volume e RSI
#define SYMBOL_STAR 108

//+------------------------------------------------------------------+
//| Enum ORIGINAL para modos de diverg√™ncia                         |
//+------------------------------------------------------------------+
enum ENUM_DIVERGENCE_MODE
{
   MODE_SENSITIVE = 0,      // Sensitive - Muitos sinais (para backtest)
   MODE_BALANCED = 1,       // Balanced - Recomendado (padr√£o)
   MODE_CONSERVATIVE = 2    // Conservative - S√≥ diverg√™ncias √≥bvias
};

//+------------------------------------------------------------------+
//| Inputs ORIGINAIS v2.38 - MANTIDOS INTEGRALMENTE                 |
//+------------------------------------------------------------------+
input int RSI_Period = 14;
input ENUM_APPLIED_PRICE RSI_Applied = PRICE_CLOSE;
input bool OnlyExtremeLevels = false;
input double OverboughtLevel = 70.0;
input double OversoldLevel = 30.0;
input int MinBarsBetweenSignals = 8;

input int Volume_Period = 14;
input double Volume_Divergence_Min = 1.5;
input double Min_Volume_Factor = 0.5;

input ENUM_DIVERGENCE_MODE DivergenceMode = MODE_BALANCED;
input int    DivergenceLookback = 18;
input int    PivotStrength = 1;
input double MinRSIDifference = 1.2;
input double MinPriceDifference = 0.025;
input bool   ShowModeInfo = true;

input group "=== üî• MELHORIAS DE VOLUME v2.2.6 ==="
input bool UseEnhancedVolumeAnalysis = true;
input bool DetectCandleVolume = true;
input bool DetectInstitutionalFlow = true;
input double CandleVolumeThreshold = 120.0;
input double InstitutionalVolumeMin = 110.0;

input group "=== üîß Tra√ßado Inteligente v2.2.6 ==="
input bool UseCleanerLines = false;
input double CleanLineTolerancePercent = 8.0;
input int MaxLineObstructions = 2;

input group "=== üî• Valida√ß√µes v2.2.6 REEQUILIBRADAS ==="
input double MinPivotAmplitude = 0.3;
input bool   RequireTrendContext = true;
input double MinQualityScore = 20.0;
input int    MinDistanceBetweenPivots = 5;
input bool   RequireCleanLine = true;

input group "=== üîß Anti Look-Ahead Settings ==="
input bool EnableAntiLookAhead = false;
input int PivotConfirmationBars = 0;

input group "=== Visual Settings ==="
input bool RequireVolumeConfirmation = false;
input bool ShowStarsOnChart = true;
input bool EnableSignalsForEA = true;
input color DividerColor = clrNONE;
input bool ShowDivergenceLines = true;
input bool ShowVolumeCircles = true;

input group "=== Debug v2.2.6 LOGS CONSOLE REDUZIDOS ==="
input bool ShowDebugInfo = true;
input bool ShowVolumeDebugOnChart = true;
input bool ShowOnlyConfirmedStars = true;
input bool ShowDetailedVolumeInfo = true;
input int MaxVolumeTextsOnChart = 25;

input group "=== üîß RSI Qualidade v2.2.6 REEQUILIBRADO ==="
input bool EnableRSITravelCheck = true;
input double RSIMaxDeviation = 25.0;
input bool EnableRSIObstructionCheck = true;
input int RSIMaxObstructions = 2;
input bool EnableRSISlopeCheck = true;
input double RSIMinSlope = 1.0;

input group "=== üî• PIV√îS FLEX√çVEIS v2.2.6 MANTIDOS ==="
input bool UseFlexiblePivots = true;
input int PivotSearchRange = 2;

input group "=== üî• Valida√ß√µes Rigorosas v2.3.8 EXTREMOS SEPARADOS ==="
input bool EnableStrictDivergenceCheck = true;
input bool EnableCleanLineCheck = true;
input double LineTolerancePercent = 5.0;
input bool RequireStrictPivots = true;
input bool ShowDivergenceValidation = true;
input int MaxSearchRangeForRSI = 5;
input bool UseCorrectedTracing = true;
input bool EnableSlopeValidation = true;

input group "=== üî• v2.40 ALINHAMENTO VERTICAL ==="
input bool UseVerticalAlignment = true;  // For√ßa alinhamento vertical perfeito
input int ExtremeLookback = 3;          // Janela para buscar extremo real (¬±barras)

//+------------------------------------------------------------------+
//| üî• STRUCT ORIGINAL: Piv√¥s com √çndices Separados                 |
//+------------------------------------------------------------------+
struct RSIPivots
{
   int rsi_pivot_past;
   int rsi_pivot_current;
   int price_pivot_past;
   int price_pivot_current;
   bool valid;
};

//+------------------------------------------------------------------+
//| üî• NOVA STRUCT v2.40: Extremos Alinhados                        |
//+------------------------------------------------------------------+
struct AlignedExtremes
{
   int bar_past;        // Barra do extremo passado
   int bar_current;     // Barra do extremo atual
   double price_past;   // Valor do pre√ßo passado
   double price_current;// Valor do pre√ßo atual
   double rsi_past;     // Valor do RSI passado
   double rsi_current;  // Valor do RSI atual
   bool valid;          // Se √© v√°lido
};

//+------------------------------------------------------------------+
//| Buffers e Vari√°veis ORIGINAIS                                   |
//+------------------------------------------------------------------+
double RSIBuffer[], BuyBuffer[], SellBuffer[], RSILineBuffer[], VolumeBuffer[];
double VolumeAvgBuffer[], VolumeBuyConfirmBuffer[], VolumeSellConfirmBuffer[], DividerBuffer[];
double BuySignalConfirmedBuffer[], SellSignalConfirmedBuffer[], RawRSIBuffer[];
double BuyStarBacktestBuffer[], SellStarBacktestBuffer[];
int starCounter = 0;
int lineCounter = 0;
int lastBuySignalBar = -1;
int lastSellSignalBar = -1;
int RSIHandle;
long g_max_volume = 1;

// Debug contadores ORIGINAIS
int divergencesDetected = 0;
int signalsConfirmed = 0;
int signalsFiltered = 0;
int qualityFiltered = 0;
int contextFiltered = 0;
int mixedTypeFiltered = 0;
int realDivFiltered = 0;
int cleanLineFiltered = 0;

// ‚úÖ CONTROLE DE SEQU√äNCIA ORIGINAL
int lastBullishPivotBar = -1;
int lastBearishPivotBar = -1;
int consecutiveBullishPivots = 0;
int consecutiveBearishPivots = 0;

// ‚úÖ LICEN√áA AJUSTADA: Conta "0" = Universal
string licenseAccount = "0";
datetime licenseExpiration = D'2025.12.31 17:55:59';

// üî• NOVO: Contador de melhorias de volume
int enhancedVolumeUsed = 0;
int volumeTextsCreated = 0;

// üî• NOVO: Controles de logs do console
static datetime lastLogTime = 0;
static int logCooldownSeconds = 10;
static int totalLogsToday = 0;
static int maxLogsPerDay = 10;
static datetime lastLogDate = 0;

// üî• NOVO: Contadores de valida√ß√µes rigorosas
int strictValidationPassed = 0;
int strictValidationFailed = 0;
int cleanLineRejections = 0;
int divergenceRejections = 0;

// üî• NOVO v2.3.8: Contadores de tra√ßado corrigido
int correctedTracingUsed = 0;
int correctLinesTraced = 0;
int alignedTracingUsed = 0;  // v2.40: contador de tra√ßados alinhados

// ‚ö° NOVO: Vari√°veis de controle tempo real
static datetime lastProcessTime = 0;
static int forceUpdateCounter = 0;
bool indicatorAlive = true;

//+------------------------------------------------------------------+
//| üî• NOVA FUN√á√ÉO v2.40: Encontrar Extremos Alinhados              |
//+------------------------------------------------------------------+
AlignedExtremes FindAlignedExtremes(const double &price[], const double &rsi[], 
                                   int current_bar, int lookback_bars, 
                                   bool is_bullish)
{
   AlignedExtremes result;
   result.valid = false;
   
   if(current_bar < lookback_bars + ExtremeLookback) return result;
   
   // Determinar o que estamos procurando
   bool looking_for_high = !is_bullish;
   
   // 1. Encontrar extremo de PRE√áO atual (dentro de uma janela pequena)
   int current_extreme = current_bar;
   double current_extreme_value = price[current_bar];
   
   // Buscar o extremo real atual numa janela de ¬±ExtremeLookback barras
   for(int i = current_bar - ExtremeLookback; i <= current_bar + ExtremeLookback; i++)
   {
      if(i < 0 || i >= ArraySize(price)) continue;
      
      if(looking_for_high)
      {
         if(price[i] > current_extreme_value)
         {
            current_extreme_value = price[i];
            current_extreme = i;
         }
      }
      else
      {
         if(price[i] < current_extreme_value)
         {
            current_extreme_value = price[i];
            current_extreme = i;
         }
      }
   }
   
   // 2. Encontrar extremo de PRE√áO passado
   int past_extreme = -1;
   double past_extreme_value = looking_for_high ? -DBL_MAX : DBL_MAX;
   
   for(int i = current_extreme - MinDistanceBetweenPivots; i >= current_extreme - lookback_bars; i--)
   {
      if(i < 0 || i >= ArraySize(price)) continue;
      
      // Verificar se √© um piv√¥ v√°lido
      if(!IsValidPivot(price, i, looking_for_high, PivotStrength)) continue;
      
      // Buscar o extremo real nessa regi√£o
      int local_extreme = i;
      double local_extreme_value = price[i];
      
      for(int j = i - ExtremeLookback; j <= i + ExtremeLookback; j++)
      {
         if(j < 0 || j >= ArraySize(price)) continue;
         
         if(looking_for_high)
         {
            if(price[j] > local_extreme_value)
            {
               local_extreme_value = price[j];
               local_extreme = j;
            }
         }
         else
         {
            if(price[j] < local_extreme_value)
            {
               local_extreme_value = price[j];
               local_extreme = j;
            }
         }
      }
      
      // Verificar se este √© um candidato melhor
      if(looking_for_high)
      {
         if(local_extreme_value > past_extreme_value)
         {
            past_extreme_value = local_extreme_value;
            past_extreme = local_extreme;
         }
      }
      else
      {
         if(local_extreme_value < past_extreme_value)
         {
            past_extreme_value = local_extreme_value;
            past_extreme = local_extreme;
         }
      }
   }
   
   // 3. Se encontramos ambos os extremos
   if(past_extreme >= 0 && current_extreme >= 0)
   {
      result.bar_past = past_extreme;
      result.bar_current = current_extreme;
      result.price_past = price[past_extreme];
      result.price_current = price[current_extreme];
      result.rsi_past = rsi[past_extreme];
      result.rsi_current = rsi[current_extreme];
      
      // 4. Validar se √© uma diverg√™ncia v√°lida
      bool valid_divergence = IsValidDivergenceDirection(
         result.price_past, result.price_current,
         result.rsi_past, result.rsi_current, is_bullish);
      
      result.valid = valid_divergence;
      
      if(result.valid)
         alignedTracingUsed++;
   }
   
   return result;
}

//+------------------------------------------------------------------+
//| üî• TODAS AS FUN√á√ïES ORIGINAIS v2.38 MANTIDAS ABAIXO            |
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| üî• NOVA FUN√á√ÉO: Buscar Extremo Real no Per√≠odo                  |
//+------------------------------------------------------------------+
int FindRealExtreme(const double &data[], int start_bar, int end_bar, bool find_highest)
{
   if(start_bar >= end_bar || start_bar < 0 || end_bar >= ArraySize(data)) 
      return start_bar;
   
   int best_bar = start_bar;
   double best_value = data[start_bar];
   
   for(int i = start_bar; i <= end_bar; i++)
   {
      if(i >= ArraySize(data)) break;
      
      if(find_highest)
      {
         if(data[i] > best_value)
         {
            best_value = data[i];
            best_bar = i;
         }
      }
      else
      {
         if(data[i] < best_value)
         {
            best_value = data[i];
            best_bar = i;
         }
      }
   }
   
   return best_bar;
}

//+------------------------------------------------------------------+
//| üî• NOVA FUN√á√ÉO: Controle de Logs do Console                     |
//+------------------------------------------------------------------+
bool CanPrintLog()
{
   datetime currentTime = TimeCurrent();
   datetime currentDate = (datetime)(currentTime / 86400) * 86400;
   
   if(currentDate != lastLogDate)
   {
      lastLogDate = currentDate;
      totalLogsToday = 0;
   }
   
   if(totalLogsToday >= maxLogsPerDay) return false;
   if(currentTime - lastLogTime < logCooldownSeconds) return false;
   
   lastLogTime = currentTime;
   totalLogsToday++;
   
   return true;
}

void PrintControlledLog(string message)
{
   if(ShowDebugInfo && CanPrintLog())
   {
      Print("üî• ", message);
   }
}

//+------------------------------------------------------------------+
//| ‚ö° NOVA FUN√á√ÉO: Sistema de Ressuscita√ß√£o do Indicador           |
//+------------------------------------------------------------------+
void ForceIndicatorUpdate()
{
   forceUpdateCounter++;
   datetime currentTime = TimeCurrent();
   
   // For√ßa atualiza√ß√£o a cada 30 segundos em tempo real
   if(!IsBacktest() && (currentTime - lastProcessTime) > 30)
   {
      lastProcessTime = currentTime;
      ChartRedraw();
      
      if(ShowDebugInfo && (forceUpdateCounter % 10 == 0))
      {
         Print("‚ö° RESSUSCITA√á√ÉO #", forceUpdateCounter, " - For√ßando atualiza√ß√£o tempo real");
      }
   }
}

//+------------------------------------------------------------------+
//| TODAS AS FUN√á√ïES ORIGINAIS MANTIDAS INTEGRALMENTE               |
//+------------------------------------------------------------------+
double ScaleRSIValue(double rsiValue) 
{ 
   return RSI_ZONE_MIN + (rsiValue / 100.0) * (RSI_ZONE_MAX - RSI_ZONE_MIN);
}

double ScaleVolumeValue(double volumeValue, long maxVolume) 
{ 
   if(maxVolume <= 0) return VOLUME_ZONE_MIN; 
   
   double normalizedVolume = (double)volumeValue / (double)maxVolume;
   if(normalizedVolume > 1.0) normalizedVolume = 1.0;
   
   return VOLUME_ZONE_MIN + (normalizedVolume * (VOLUME_ZONE_MAX - VOLUME_ZONE_MIN)); 
}

bool IsBacktest()
{
   return (MQLInfoInteger(MQL_TESTER) || 
           MQLInfoInteger(MQL_OPTIMIZATION) ||
           MQLInfoInteger(MQL_VISUAL_MODE));
}

bool IsVisualMode()
{
   return MQLInfoInteger(MQL_VISUAL_MODE);
}

//+------------------------------------------------------------------+
//| ‚ö° FUN√á√ÉO CORRIGIDA: IsValidPivot TEMPO REAL v2.3.7             |
//+------------------------------------------------------------------+
bool IsValidPivot(const double &data[], int position, bool isHigh, int strength)
{
   // ‚ö° CORRE√á√ÉO CR√çTICA: Verifica√ß√£o de validade do array
   if(ArraySize(data) == 0) return false;
   
   // ‚ö° CORRE√á√ÉO v2.3.7: Diferencia√ß√£o entre backtest e tempo real
   int max_allowed = IsBacktest() ? ArraySize(data) - strength : ArraySize(data) - 1;
   if(position < strength || position >= max_allowed) return false;
   
   for(int i = 1; i <= strength; i++)
   {
      if(isHigh)
      {
         if(data[position] <= data[position - i]) return false;
         
         if(position + i < ArraySize(data) && data[position] <= data[position + i])
            return false;
      }
      else
      {
         if(data[position] >= data[position - i]) return false;
         
         if(position + i < ArraySize(data) && data[position] >= data[position + i])
            return false;
      }
   }
   return true;
}

bool IsStrongPivot(const double &data[], int position, bool isHigh, int strength, double min_amplitude)
{
   if(!IsValidPivot(data, position, isHigh, strength)) return false;
   
   double amplitude = 0;
   for(int i = 1; i <= strength; i++)
   {
      if(isHigh)
      {
         double left = data[position-i];
         double right = (position+i < ArraySize(data)) ? data[position+i] : data[position-i];
         amplitude = MathMax(amplitude, data[position] - MathMin(left, right));
      }
      else
      {
         double left = data[position-i];  
         double right = (position+i < ArraySize(data)) ? data[position+i] : data[position-i];
         amplitude = MathMax(amplitude, MathMax(left, right) - data[position]);
      }
   }
   
   return (amplitude >= min_amplitude);
}

bool IsRealDivergence(double price1, double price2, double rsi1, double rsi2, bool is_bullish)
{
   double price_diff_percent = MathAbs((price2 - price1) / price1) * 100.0;
   double rsi_diff = MathAbs(rsi2 - rsi1);
   
   if(price_diff_percent < 0.005) return false;  
   if(rsi_diff < 0.3) return false;              
   
   if(is_bullish)
   {
      return (price2 < price1 && rsi2 > rsi1);
   }
   else
   {
      return (price2 > price1 && rsi2 < rsi1);
   }
}

bool IsValidTrendContext(const double &price[], int pivot, int current, bool is_bullish)
{
   if(RequireTrendContext == false) return true;
   
   int lookback = 15;
   if(current < lookback) return true;
   
   double start_price = price[current - lookback];
   double end_price = price[current];
   double trend_slope = (end_price - start_price) / lookback;
   
   double mid_price = price[current - lookback/2];
   
   if(is_bullish)
   {
      bool declining_trend = (trend_slope <= 0.0001);
      bool came_from_high = (mid_price > end_price);
      return (declining_trend || came_from_high);
   }
   else
   {
      bool rising_trend = (trend_slope >= -0.0001);
      bool came_from_low = (mid_price < end_price);
      return (rising_trend || came_from_low);
   }
}

bool HasMinimumLineSlope(double price1, double price2, double rsi1, double rsi2, int bars_distance, bool is_bullish)
{
   if(bars_distance <= 1) return false;
   
   double price_slope_per_bar = MathAbs(price2 - price1) / bars_distance;
   double price_change_percent = MathAbs((price2 - price1) / price1) * 100.0;
   
   double rsi_slope_per_bar = MathAbs(rsi2 - rsi1) / bars_distance;
   
   double min_price_change = MinPriceDifference;
   double min_rsi_change = RSIMinSlope;
   
   bool price_slope_ok = (price_change_percent >= min_price_change);
   bool rsi_slope_ok = (rsi_slope_per_bar >= (min_rsi_change / bars_distance));
   
   if(ShowDebugInfo && CanPrintLog() && (!price_slope_ok || !rsi_slope_ok))
   {
      PrintControlledLog("INCLINA√á√ÉO INSUFICIENTE - Pre√ßo: " + DoubleToString(price_change_percent, 3) + "% | RSI: " + DoubleToString(rsi_slope_per_bar, 2));
   }
   
   return (price_slope_ok && rsi_slope_ok);
}

bool IsValidRSISequence(int current_bar, bool is_bullish)
{
   if(is_bullish)
   {
      if(lastBullishPivotBar > 0 && (current_bar - lastBullishPivotBar) <= 8)
      {
         consecutiveBullishPivots++;
         if(consecutiveBullishPivots >= 3)
         {
            PrintControlledLog("BULLISH REJEITADO - Muitos fundos consecutivos (" + (string)consecutiveBullishPivots + ")");
            return false;
         }
      }
      else
      {
         consecutiveBullishPivots = 0;
      }
      lastBullishPivotBar = current_bar;
   }
   else
   {
      if(lastBearishPivotBar > 0 && (current_bar - lastBearishPivotBar) <= 8)
      {
         consecutiveBearishPivots++;
         if(consecutiveBearishPivots >= 3)
         {
            PrintControlledLog("BEARISH REJEITADO - Muitos topos consecutivos (" + (string)consecutiveBearishPivots + ")");
            return false;
         }
      }
      else
      {
         consecutiveBearishPivots = 0;
      }
      lastBearishPivotBar = current_bar;
   }
   
   return true;
}

bool CheckSignificance(double price1, double price2, double rsi1, double rsi2, 
                       bool is_bullish, ENUM_DIVERGENCE_MODE mode)
{
   double rsi_diff = MathAbs(rsi2 - rsi1);
   double price_diff_percent = MathAbs((price2 - price1) / price1) * 100.0;
   
   switch(mode)
   {
      case MODE_SENSITIVE:
         return (rsi_diff >= 0.05 && price_diff_percent >= 0.0005); 
         
      case MODE_BALANCED:
         return (rsi_diff >= 0.8 && price_diff_percent >= 0.02); 
         
      case MODE_CONSERVATIVE:
         return (rsi_diff >= MinRSIDifference * 0.3 && price_diff_percent >= MinPriceDifference * 0.3); 
   }
   
   return false;
}

double GetVolumeChangePercent(const long &tick_volume[], int start, int end) 
{ 
   if(end <= start || start < Volume_Period || end >= ArraySize(tick_volume)) return 0.0; 
   
   int compare_period = MathMin(5, (end - start) / 2);
   
   long sum_recent = 0;
   for(int i = 0; i < compare_period; i++) 
   {
      if(end - i >= 0) sum_recent += tick_volume[end - i];
   }
   double avg_recent = (double)sum_recent / compare_period;
   
   long sum_previous = 0;
   for(int i = 0; i < compare_period; i++) 
   {
      if(start - i >= 0) sum_previous += tick_volume[start - i];
   }
   double avg_previous = (double)sum_previous / compare_period;
   
   if(avg_previous <= 0) return 0.0;
   double visual_method = ((avg_recent - avg_previous) / avg_previous) * 100.0;
   
   long sum_long = 0; 
   for(int i = 0; i < Volume_Period; i++) 
   {
      if(end - i >= 0) sum_long += tick_volume[end - i]; 
   }
   double avg_long = (double)sum_long / Volume_Period;
   double current_vs_avg = (avg_previous > 0) ? ((avg_recent - avg_long) / avg_long) * 100.0 : 0.0;
   
   double result = (MathAbs(visual_method) > MathAbs(current_vs_avg)) ? current_vs_avg : visual_method;
   
   return result;
}

bool CheckVolumeConfirmation(bool is_buy, const long &tick_volume[], int start, int end) 
{ 
   double volumeChange = GetVolumeChangePercent(tick_volume, start, end); 
   bool vol_confirmed = (volumeChange >= Volume_Divergence_Min);
   return vol_confirmed;
}

bool CheckMinimumVolume(const long &tick_volume[], int position) 
{ 
   if(position < Volume_Period) return true; 
   long totalVolume = 0; 
   for(int i = position - Volume_Period + 1; i <= position; i++) 
      totalVolume += tick_volume[i]; 
   double avgVolume = (double)totalVolume / Volume_Period; 
   return ((double)tick_volume[position] >= (avgVolume * Min_Volume_Factor)); 
}

double CalculateDivergenceScore(double price1, double price2, double rsi1, double rsi2, 
                               int pivot, int current, const long &volume[], bool is_bullish)
{
   double score = 15;
   
   double rsi_strength = MathAbs(rsi2 - rsi1);
   score += MathMin(rsi_strength * 8, 30); 
   
   double price_strength = MathAbs((price2 - price1) / price1) * 100;
   score += MathMin(price_strength * 25, 25); 
   
   if(current > pivot && pivot >= Volume_Period && current >= Volume_Period)
   {
      double vol_change = GetVolumeChangePercent(volume, pivot, current);
      if(vol_change > 0.5)
         score += 25;
      else if(MathAbs(vol_change) > 0.2)
         score += 20;
      else
         score += 18; 
   }
   else
   {
      score += 22; 
   }
   
   score += 18; 
   
   return score;
}

bool CheckCandleDirectionVolume(const double &open[], const double &close[], 
                               const long &volume[], int position, bool for_buy, int lookback = 5)
{
   if(DetectCandleVolume == false || position < lookback) return true;
   
   long totalTargetVolume = 0;
   long totalVolume = 0;
   
   for(int i = 0; i < lookback; i++)
   {
      int bar = position - i;
      if(bar < 0) break;
      
      totalVolume += volume[bar];
      
      bool isTargetCandle = for_buy ? (close[bar] > open[bar]) : (close[bar] < open[bar]);
      
      if(isTargetCandle)
         totalTargetVolume += volume[bar];
   }
   
   if(totalVolume == 0) return true;
   
   double targetVolumePercent = ((double)totalTargetVolume / (double)totalVolume) * 100.0;
   bool confirmed = (targetVolumePercent >= CandleVolumeThreshold);
   
   return confirmed;
}

bool CheckInstitutionalVolumeFlow(const double &price_ref[], const long &volume[], 
                                 int pivot, int current, bool for_buy)
{
   if(DetectInstitutionalFlow == false || current <= pivot) return true;
   
   long sum_volume = 0;
   int period = current - pivot;
   for(int i = 0; i < period && (current - i) >= 0; i++)
      sum_volume += volume[current - i];
   
   double avg_volume_period = (period > 0) ? (double)sum_volume / period : 0;
   
   long sum_general = 0;
   int general_start = MathMax(0, pivot - Volume_Period);
   for(int i = general_start; i < pivot && i >= 0; i++)
      sum_general += volume[i];
   double avg_volume_general = (Volume_Period > 0) ? (double)sum_general / Volume_Period : 1;
   
   double volume_ratio = (avg_volume_general > 0) ? (avg_volume_period / avg_volume_general) * 100.0 : 100.0;
   
   double price_change_percent = MathAbs((price_ref[current] - price_ref[pivot]) / price_ref[pivot]) * 100.0;
   
   bool institutional_flow = (volume_ratio >= InstitutionalVolumeMin) && (price_change_percent >= 0.2);
   
   return institutional_flow;
}

bool CheckRSITravelDistance(const double &rsi[], int start_bar, int end_bar, bool is_bullish)
{
   if(EnableRSITravelCheck == false) return true;
   
   if(start_bar == end_bar) return false;
   
   double start_rsi = rsi[start_bar];
   double end_rsi = rsi[end_bar];
   
   for(int i = MathMin(start_bar, end_bar) + 1; i < MathMax(start_bar, end_bar); i++)
   {
      if(is_bullish)
      {
         double max_allowed_rsi = MathMax(start_rsi, end_rsi) + RSIMaxDeviation;
         if(rsi[i] > max_allowed_rsi && rsi[i] > 45.0)
         {
            PrintControlledLog("RSI ESTICOU DEMAIS (Bullish) - Barra " + (string)i + " | RSI: " + DoubleToString(rsi[i], 1));
            return false;
         }
      }
      else
      {
         double min_allowed_rsi = MathMin(start_rsi, end_rsi) - RSIMaxDeviation;
         if(rsi[i] < min_allowed_rsi && rsi[i] < 55.0)
         {
            PrintControlledLog("RSI ESTICOU DEMAIS (Bearish) - Barra " + (string)i + " | RSI: " + DoubleToString(rsi[i], 1));
            return false;
         }
      }
   }
   
   return true;
}

bool CheckRSILineObstruction(const double &rsi[], int start_bar, int end_bar, bool is_bullish)
{
   if(EnableRSIObstructionCheck == false) return true;
   
   if(start_bar == end_bar) return false;
   if(start_bar > end_bar) { int temp = start_bar; start_bar = end_bar; end_bar = temp; }
   
   double start_rsi = rsi[start_bar];
   double end_rsi = rsi[end_bar];
   int significant_obstructions = 0;
   int max_obstructions = RSIMaxObstructions;
   
   for(int i = start_bar + 1; i < end_bar; i++)
   {
      double line_ratio = (double)(i - start_bar) / (double)(end_bar - start_bar);
      double expected_rsi_on_line = start_rsi + (end_rsi - start_rsi) * line_ratio;
      
      bool is_rsi_pivot = IsValidPivot(rsi, i, !is_bullish, 1);
      
      if(is_rsi_pivot)
      {
         if(is_bullish)
         {
            if(rsi[i] > expected_rsi_on_line + 3.0)
            {
               significant_obstructions++;
            }
         }
         else
         {
            if(rsi[i] < expected_rsi_on_line - 3.0)
            {
               significant_obstructions++;
            }
         }
         
         if(significant_obstructions > max_obstructions)
         {
            PrintControlledLog("LINHA RSI CORTADA - Muitas obstru√ß√µes (" + (string)significant_obstructions + ")");
            return false;
         }
      }
   }
   
   return true;
}

bool CheckRSILineSlope(double rsi1, double rsi2, int bars_distance, bool is_bullish)
{
   if(EnableRSISlopeCheck == false) return true;
   
   if(bars_distance <= 1) return false;
   
   double rsi_diff = MathAbs(rsi2 - rsi1);
   double min_rsi_slope = RSIMinSlope;
   double min_rsi_slope_per_bar = min_rsi_slope / bars_distance;
   
   double actual_rsi_slope_per_bar = rsi_diff / bars_distance;
   
   if(actual_rsi_slope_per_bar < min_rsi_slope_per_bar)
   {
      PrintControlledLog("RSI MUITO RETO - Diferen√ßa RSI: " + DoubleToString(rsi_diff, 1) + " | Dist√¢ncia: " + (string)bars_distance);
      return false;
   }
   
   if(is_bullish)
   {
      if(rsi2 <= rsi1)
      {
         PrintControlledLog("RSI DIRE√á√ÉO ERRADA (Bullish) - RSI1: " + DoubleToString(rsi1, 1) + " | RSI2: " + DoubleToString(rsi2, 1));
         return false;
      }
   }
   else
   {
      if(rsi2 >= rsi1)
      {
         PrintControlledLog("RSI DIRE√á√ÉO ERRADA (Bearish) - RSI1: " + DoubleToString(rsi1, 1) + " | RSI2: " + DoubleToString(rsi2, 1));
         return false;
      }
   }
   
   return true;
}

bool CheckRSIQuality(const double &rsi[], int start_bar, int end_bar, bool is_bullish)
{
   if(!CheckRSITravelDistance(rsi, start_bar, end_bar, is_bullish))
      return false;
   
   if(!CheckRSILineObstruction(rsi, start_bar, end_bar, is_bullish))
      return false;
   
   if(!CheckRSILineSlope(rsi[start_bar], rsi[end_bar], MathAbs(end_bar - start_bar), is_bullish))
      return false;
   
   return true;
}

bool IsCleanDivergenceLine(const double &price[], const double &rsi[], int start_bar, int end_bar, bool is_bullish)
{
   if(UseCleanerLines == false) return true;
   
   if(start_bar == end_bar) return false;
   if(start_bar > end_bar) { int temp = start_bar; start_bar = end_bar; end_bar = temp; }
   
   double start_price = price[start_bar];
   double end_price = price[end_bar];
   
   double price_tolerance = MathAbs(end_price - start_price) * (CleanLineTolerancePercent / 100.0);
   
   int obstructions_found = 0;
   
   for(int i = start_bar + 1; i < end_bar; i++)
   {
      if(is_bullish)
      {
         bool is_significant_low = IsValidPivot(price, i, false, 1);
         
         if(is_significant_low)
         {
            double line_ratio = (double)(i - start_bar) / (double)(end_bar - start_bar);
            double expected_price_on_line = start_price + (end_price - start_price) * line_ratio;
            
            if(price[i] < (expected_price_on_line - price_tolerance))
            {
               obstructions_found++;
               
               if(obstructions_found > MaxLineObstructions)
               {
                  PrintControlledLog("LINHA REJEITADA (Bullish) - Muitas obstru√ß√µes (" + (string)obstructions_found + ")");
                  return false;
               }
            }
         }
      }
      else
      {
         bool is_significant_high = IsValidPivot(price, i, true, 1);
         
         if(is_significant_high)
         {
            double line_ratio = (double)(i - start_bar) / (double)(end_bar - start_bar);
            double expected_price_on_line = start_price + (end_price - start_price) * line_ratio;
            
            if(price[i] > (expected_price_on_line + price_tolerance))
            {
               obstructions_found++;
               
               if(obstructions_found > MaxLineObstructions)
               {
                  PrintControlledLog("LINHA REJEITADA (Bearish) - Muitas obstru√ß√µes (" + (string)obstructions_found + ")");
                  return false;
               }
            }
         }
      }
   }
   
   return true;
}

bool IsValidCandleContext(const double &open[], const double &close[], 
                         const double &high[], const double &low[], 
                         int position, bool is_buy_signal)
{
   if(position < 3) return true;
   
   int bullish_candles = 0;
   int bearish_candles = 0;
   
   for(int i = 0; i < 3; i++)
   {
      int bar = position - i;
      if(bar >= 0)
      {
         if(close[bar] > open[bar]) bullish_candles++;
         if(close[bar] < open[bar]) bearish_candles++;
      }
   }
   
   if(is_buy_signal)
   {
      if(bullish_candles >= 3)
      {
         if(ShowDivergenceValidation)
            PrintControlledLog("COMPRA REJEITADA - Contexto muito otimista (3 candles verdes)");
         return false;
      }
      
      return true;
   }
   else
   {
      if(bearish_candles >= 3)
      {
         if(ShowDivergenceValidation)
            PrintControlledLog("VENDA REJEITADA - Contexto muito pessimista (3 candles vermelhos)");
         return false;
      }
      
      return true;
   }
}

bool IsValidConfirmationTiming(const double &open[], const double &close[], 
                              const double &high[], const double &low[], 
                              int position, bool is_buy_signal)
{
   if(position < 1) return true;
   
   bool current_candle_bullish = (close[position] > open[position]);
   bool current_candle_bearish = (close[position] < open[position]);
   
   if(is_buy_signal)
   {
      if(current_candle_bullish)
      {
         double candle_size = MathAbs(close[position] - open[position]);
         double candle_range = high[position] - low[position];
         double body_ratio = (candle_range > 0) ? candle_size / candle_range : 0;
         
         if(body_ratio > 0.7)
         {
            if(ShowDivergenceValidation)
               PrintControlledLog("COMPRA REJEITADA - Candle verde muito forte (" + DoubleToString(body_ratio*100, 0) + "% corpo)");
            return false;
         }
      }
      
      return true;
   }
   else
   {
      if(current_candle_bearish)
      {
         double candle_size = MathAbs(close[position] - open[position]);
         double candle_range = high[position] - low[position];
         double body_ratio = (candle_range > 0) ? candle_size / candle_range : 0;
         
         if(body_ratio > 0.7)
         {
            if(ShowDivergenceValidation)
               PrintControlledLog("VENDA REJEITADA - Candle vermelho muito forte (" + DoubleToString(body_ratio*100, 0) + "% corpo)");
            return false;
         }
      }
      
      return true;
   }
}

bool IsValidDivergenceDirection(double price_past, double price_current, 
                               double rsi_past, double rsi_current, bool is_bullish)
{
   if(is_bullish)
   {
      bool price_lower = (price_current < price_past);
      bool rsi_higher = (rsi_current > rsi_past);
      
      if(ShowDivergenceValidation && (!price_lower || !rsi_higher))
      {
         PrintControlledLog("COMPRA REJEITADA - Pre√ßo: " + (price_lower ? "‚úìMais baixo" : "‚úóN√£o mais baixo") + 
                           " | RSI: " + (rsi_higher ? "‚úìMais alto" : "‚úóN√£o mais alto"));
         divergenceRejections++;
      }
      
      return (price_lower && rsi_higher);
   }
   else
   {
      bool price_higher = (price_current > price_past);
      bool rsi_lower = (rsi_current < rsi_past);
      
      if(ShowDivergenceValidation && (!price_higher || !rsi_lower))
      {
         PrintControlledLog("VENDA REJEITADA - Pre√ßo: " + (price_higher ? "‚úìMais alto" : "‚úóN√£o mais alto") + 
                           " | RSI: " + (rsi_lower ? "‚úìMais baixo" : "‚úóN√£o mais baixo"));
         divergenceRejections++;
      }
      
      return (price_higher && rsi_lower);
   }
}

bool IsRealExtreme(const double &data[], int pivot_pos, bool is_high, int verification_range = 3)
{
   if(pivot_pos < verification_range || pivot_pos >= ArraySize(data) - verification_range) 
      return false;
   
   if(is_high)
   {
      for(int i = pivot_pos - verification_range; i <= pivot_pos + verification_range; i++)
      {
         if(i != pivot_pos && data[i] >= data[pivot_pos])
            return false;
      }
   }
   else
   {
      for(int i = pivot_pos - verification_range; i <= pivot_pos + verification_range; i++)
      {
         if(i != pivot_pos && data[i] <= data[pivot_pos])
            return false;
      }
   }
   
   return true;
}

bool ValidateLineDoesNotCutPivots(const double &data[], int start_bar, int end_bar, 
                                 bool is_bullish, double tolerance_percent = 3.0)
{
   if(start_bar >= end_bar) return false;
   
   double start_value = data[start_bar];
   double end_value = data[end_bar];
   double line_tolerance = MathAbs(end_value - start_value) * (tolerance_percent / 100.0);
   
   int cuts_found = 0;
   int max_cuts_allowed = 1;
   
   for(int i = start_bar + 1; i < end_bar; i++)
   {
      double line_ratio = (double)(i - start_bar) / (double)(end_bar - start_bar);
      double expected_line_value = start_value + (end_value - start_value) * line_ratio;
      
      bool is_significant_pivot = IsValidPivot(data, i, !is_bullish, 2);
      
      if(is_significant_pivot)
      {
         if(is_bullish)
         {
            if(data[i] > (expected_line_value + line_tolerance))
            {
               cuts_found++;
            }
         }
         else
         {
            if(data[i] < (expected_line_value - line_tolerance))
            {
               cuts_found++;
            }
         }
         
         if(cuts_found > max_cuts_allowed)
         {
            if(ShowDivergenceValidation)
               PrintControlledLog("LINHA REJEITADA - Corta " + (string)cuts_found + " piv√¥s significativos");
            return false;
         }
      }
   }
   
   return true;
}

bool LinePassesCleanly(const double &data[], int start_bar, int end_bar, 
                      bool is_bullish, double tolerance_percent = 5.0)
{
   // ‚ö° CORRE√á√ÉO CRITICAL: Verifica√ß√£o de boolean corrigida (linha 354 original)
   if(EnableCleanLineCheck == false) return true;
   if(start_bar >= end_bar) return false;
   
   double start_value = data[start_bar];
   double end_value = data[end_bar];
   double line_tolerance = MathAbs(end_value - start_value) * (tolerance_percent / 100.0);
   
   for(int i = start_bar + 1; i < end_bar; i++)
   {
      double line_ratio = (double)(i - start_bar) / (double)(end_bar - start_bar);
      double expected_line_value = start_value + (end_value - start_value) * line_ratio;
      
      if(is_bullish)
      {
         bool is_significant_low = IsValidPivot(data, i, false, 1);
         
         if(is_significant_low && data[i] < (expected_line_value - line_tolerance))
         {
            if(ShowDivergenceValidation)
            {
               PrintControlledLog("LINHA CORTADA (Compra) - Fundo intermedi√°rio na barra " + (string)i);
               cleanLineRejections++;
            }
            return false;
         }
      }
      else
      {
         bool is_significant_high = IsValidPivot(data, i, true, 1);
         
         if(is_significant_high && data[i] > (expected_line_value + line_tolerance))
         {
            if(ShowDivergenceValidation)
            {
               PrintControlledLog("LINHA CORTADA (Venda) - Topo intermedi√°rio na barra " + (string)i);
               cleanLineRejections++;
            }
            return false;
         }
      }
   }
   
   return true;
}

RSIPivots FindRSIPivotsStrict(const double &rsi_raw[], int price_pivot, int price_current, 
                             bool is_bullish, double price_past, double price_current_val)
{
   RSIPivots result;
   result.valid = false;
   
   result.price_pivot_past = price_pivot;
   result.price_pivot_current = price_current;
   result.rsi_pivot_past = price_pivot;
   result.rsi_pivot_current = price_current;
   
   if(UseCorrectedTracing == false)
   {
      result.rsi_pivot_past = price_pivot;
      result.rsi_pivot_current = price_current;
      result.valid = true;
      return result;
   }
   
   int search_range = MaxSearchRangeForRSI;
   
   int best_rsi_past = -1;
   int best_rsi_current = -1;
   double best_score_past = -1;
   double best_score_current = -1;
   
   if(is_bullish)
   {
      for(int i = price_pivot - search_range; i <= price_pivot + search_range; i++)
      {
         if(i >= 2 && i < ArraySize(rsi_raw) - 2)
         {
            if(IsValidPivot(rsi_raw, i, false, 1) && IsRealExtreme(rsi_raw, i, false, 2))
            {
               double proximity_score = 10.0 - MathAbs(i - price_pivot);
               double depth_score = 50.0 - rsi_raw[i];
               double total_score = proximity_score + depth_score;
               
               if(total_score > best_score_past)
               {
                  best_score_past = total_score;
                  best_rsi_past = i;
               }
            }
         }
      }
      
      for(int i = price_current - search_range; i <= price_current + search_range; i++)
      {
         if(i >= 2 && i < ArraySize(rsi_raw) - 2)
         {
            if(IsValidPivot(rsi_raw, i, false, 1) && IsRealExtreme(rsi_raw, i, false, 2))
            {
               double proximity_score = 10.0 - MathAbs(i - price_current);
               double depth_score = 50.0 - rsi_raw[i];
               double total_score = proximity_score + depth_score;
               
               if(total_score > best_score_current)
               {
                  best_score_current = total_score;
                  best_rsi_current = i;
               }
            }
         }
      }
   }
   else
   {
      for(int i = price_pivot - search_range; i <= price_pivot + search_range; i++)
      {
         if(i >= 2 && i < ArraySize(rsi_raw) - 2)
         {
            if(IsValidPivot(rsi_raw, i, true, 1) && IsRealExtreme(rsi_raw, i, true, 2))
            {
               double proximity_score = 10.0 - MathAbs(i - price_pivot);
               double height_score = rsi_raw[i] - 50.0;
               double total_score = proximity_score + height_score;
               
               if(total_score > best_score_past)
               {
                  best_score_past = total_score;
                  best_rsi_past = i;
               }
            }
         }
      }
      
      for(int i = price_current - search_range; i <= price_current + search_range; i++)
      {
         if(i >= 2 && i < ArraySize(rsi_raw) - 2)
         {
            if(IsValidPivot(rsi_raw, i, true, 1) && IsRealExtreme(rsi_raw, i, true, 2))
            {
               double proximity_score = 10.0 - MathAbs(i - price_current);
               double height_score = rsi_raw[i] - 50.0;
               double total_score = proximity_score + height_score;
               
               if(total_score > best_score_current)
               {
                  best_score_current = total_score;
                  best_rsi_current = i;
               }
            }
         }
      }
   }
   
   if(best_rsi_past != -1 && best_rsi_current != -1)
   {
      result.rsi_pivot_past = best_rsi_past;
      result.rsi_pivot_current = best_rsi_current;
      
      bool valid_divergence = IsValidDivergenceDirection(price_past, price_current_val, 
                                                        rsi_raw[result.rsi_pivot_past], 
                                                        rsi_raw[result.rsi_pivot_current], is_bullish);
      
      bool lines_diverge = false;
      double price_slope = price_current_val - price_past;
      double rsi_slope = rsi_raw[result.rsi_pivot_current] - rsi_raw[result.rsi_pivot_past];
      
      double min_slope_threshold = 0.0001;
      
      if(is_bullish)
      {
         bool price_declining = (price_slope < -min_slope_threshold);
         bool rsi_rising = (rsi_slope > min_slope_threshold);
         lines_diverge = (price_declining && rsi_rising);
         
         if(ShowDivergenceValidation && !lines_diverge)
         {
            PrintControlledLog("COMPRA REJEITADA - Dire√ß√µes incorretas | Pre√ßo slope: " + DoubleToString(price_slope, 6) + 
                              " | RSI slope: " + DoubleToString(rsi_slope, 3) + 
                              " | Esperado: Pre√ßo‚ÜòÔ∏è + RSI‚ÜóÔ∏è");
         }
      }
      else
      {
         bool price_rising = (price_slope > min_slope_threshold);
         bool rsi_declining = (rsi_slope < -min_slope_threshold);
         lines_diverge = (price_rising && rsi_declining);
         
         if(ShowDivergenceValidation && !lines_diverge)
         {
            PrintControlledLog("VENDA REJEITADA - Dire√ß√µes incorretas | Pre√ßo slope: " + DoubleToString(price_slope, 6) + 
                              " | RSI slope: " + DoubleToString(rsi_slope, 3) + 
                              " | Esperado: Pre√ßo‚ÜóÔ∏è + RSI‚ÜòÔ∏è");
         }
      }
      
      bool rsi_line_clean = ValidateLineDoesNotCutPivots(rsi_raw, result.rsi_pivot_past, result.rsi_pivot_current, is_bullish, 5.0);
      
      result.valid = (valid_divergence && lines_diverge && rsi_line_clean);
      
      if(result.valid) 
      {
         strictValidationPassed++;
         correctedTracingUsed++;
         
         if(ShowDivergenceValidation)
         {
            string type = is_bullish ? "COMPRA" : "VENDA";
            PrintControlledLog(type + " TRA√áADO CORRIGIDO - Pre√ßo: " + (string)result.price_pivot_past + "‚Üí" + (string)result.price_pivot_current + 
                              " | RSI: " + (string)result.rsi_pivot_past + "‚Üí" + (string)result.rsi_pivot_current);
         }
      }
      else 
      {
         strictValidationFailed++;
         if(ShowDivergenceValidation)
         {
            string reason = !valid_divergence ? "N√£o √© diverg√™ncia" : 
                           !lines_diverge ? "Linhas mesma dire√ß√£o" : 
                           "Linha RSI cortada";
            PrintControlledLog("TRA√áADO REJEITADO - " + reason);
         }
      }
   }
   else
   {
      result.valid = false;
      strictValidationFailed++;
      if(ShowDivergenceValidation)
         PrintControlledLog("PIV√îS N√ÉO ENCONTRADOS - Sem extremos RSI adequados pr√≥ximos aos de pre√ßo");
   }
   
   return result;
}

int FindBestPivotForCleanLine(const double &price[], const double &rsi_raw[], const long &tick_volume[], 
                             int current, bool is_bullish, double level, int pivot_strength)
{
   bool lookingForHighInPast = !is_bullish;
   
   if(UseCleanerLines == false) 
   {
      for(int i = current - MinDistanceBetweenPivots; i >= current - DivergenceLookback; i--)
      {
         if(i < pivot_strength) break;
         
         bool priceIsPivot = IsValidPivot(price, i, lookingForHighInPast, pivot_strength);
         bool rsiIsPivot = IsValidPivot(rsi_raw, i, lookingForHighInPast, pivot_strength);
         
         if(priceIsPivot && rsiIsPivot)
         {
            bool level_ok;
            if(is_bullish) {
               level_ok = (rsi_raw[i] < level);
            } else {
               level_ok = (rsi_raw[i] > level);
            }
            
            if(level_ok && IsStrongPivot(rsi_raw, i, lookingForHighInPast, pivot_strength, MinPivotAmplitude))
            {
               return i;
            }
         }
      }
      return -1;
   }
   
   int best_pivot = -1;
   double best_score = -1;
   
   for(int i = current - MinDistanceBetweenPivots; i >= current - DivergenceLookback; i--)
   {
      if(i < pivot_strength) break;
      
      bool priceIsPivot = IsValidPivot(price, i, lookingForHighInPast, pivot_strength);
      bool rsiIsPivot = IsValidPivot(rsi_raw, i, lookingForHighInPast, pivot_strength);
      
      if(priceIsPivot && rsiIsPivot)
      {
         bool level_ok;
         if(is_bullish) {
            level_ok = (rsi_raw[i] < level);
         } else {
            level_ok = (rsi_raw[i] > level);
         }
         
         if(level_ok && IsStrongPivot(rsi_raw, i, lookingForHighInPast, pivot_strength, MinPivotAmplitude))
         {
            bool would_have_clean_line = IsCleanDivergenceLine(price, rsi_raw, i, current, is_bullish);
            
            double line_score = 30;
            
            if(is_bullish) {
               if(price[current] < price[i] && rsi_raw[current] > rsi_raw[i])
                  line_score += 40;
            } else {
               if(price[current] > price[i] && rsi_raw[current] < rsi_raw[i])
                  line_score += 40;
            }
            
            if(would_have_clean_line)
               line_score += 20;
            
            double rsi_diff = MathAbs(rsi_raw[current] - rsi_raw[i]);
            line_score += rsi_diff;
            
            line_score += (DivergenceLookback - (current - i)) * 0.5;
            
            if(line_score > best_score)
            {
               best_pivot = i;
               best_score = line_score;
            }
         }
      }
   }
   
   return best_pivot;
}

bool FindFlexiblePivots(const double &price[], const double &rsi_raw[], int current, bool is_bullish, 
                       int pivot_strength, bool &currentPriceIsPivot, bool &currentRsiIsPivot)
{
   currentPriceIsPivot = false;
   currentRsiIsPivot = false;
   
   bool lookingForHigh = !is_bullish;
   
   if(UseFlexiblePivots == false)
   {
      currentPriceIsPivot = IsValidPivot(price, current, lookingForHigh, pivot_strength);
      currentRsiIsPivot = IsValidPivot(rsi_raw, current, lookingForHigh, pivot_strength);
      return (currentPriceIsPivot && currentRsiIsPivot);
   }
   
   int search_range = PivotSearchRange;
   
   for(int p = current - search_range; p <= current + search_range; p++)
   {
      if(p >= 0 && p < ArraySize(price) && IsValidPivot(price, p, lookingForHigh, pivot_strength))
      {
         currentPriceIsPivot = true;
         break;
      }
   }
   
   for(int r = current - search_range; r <= current + search_range; r++)
   {
      if(r >= 0 && r < ArraySize(rsi_raw) && IsValidPivot(rsi_raw, r, lookingForHigh, pivot_strength))
      {
         currentRsiIsPivot = true;
         break;
      }
   }
   
   return (currentPriceIsPivot && currentRsiIsPivot);
}

int CheckClassicDivergence(const double &price[], const double &rsi_raw[], const long &tick_volume[], 
                          const double &open[], const double &close[], int current, bool is_bullish)
{
   if(current < DivergenceLookback) return -1;

   int pivot_strength = (DivergenceMode == MODE_CONSERVATIVE) ? PivotStrength + 1 : PivotStrength;
   
   double level = is_bullish ? (OnlyExtremeLevels ? OversoldLevel : 45.0) : (OnlyExtremeLevels ? OverboughtLevel : 55.0);
   
   int pivot = FindBestPivotForCleanLine(price, rsi_raw, tick_volume, current, is_bullish, level, pivot_strength);
   
   if(pivot > 0)
   {
      bool currentPriceIsPivot = false;
      bool currentRsiIsPivot = false;
      bool pivotsFound = FindFlexiblePivots(price, rsi_raw, current, is_bullish, pivot_strength, currentPriceIsPivot, currentRsiIsPivot);
      
      bool price_condition, rsi_condition, level_condition;
      
      if(is_bullish) {
         price_condition = (price[current] < price[pivot]);
         rsi_condition = (rsi_raw[current] > rsi_raw[pivot]);
         level_condition = (rsi_raw[current] < level);
      } else {
         price_condition = (price[current] > price[pivot]);
         rsi_condition = (rsi_raw[current] < rsi_raw[pivot]);
         level_condition = (rsi_raw[current] > level);
      }
      
      if(price_condition && rsi_condition && level_condition)
      {
         double price_slope = price[current] - price[pivot];
         double rsi_slope = rsi_raw[current] - rsi_raw[pivot];
         double min_slope_threshold = 0.0001;
         
         bool valid_slopes = false;
         if(is_bullish)
         {
            valid_slopes = (price_slope < -min_slope_threshold) && (rsi_slope > min_slope_threshold);
            if(!valid_slopes && ShowDivergenceValidation)
            {
               PrintControlledLog("COMPRA REJEITADA - Slopes incorretos | Pre√ßo: " + DoubleToString(price_slope, 6) + 
                                " | RSI: " + DoubleToString(rsi_slope, 3) + " | Necess√°rio: Pre√ßo‚ÜòÔ∏è + RSI‚ÜóÔ∏è");
               return -1;
            }
         }
         else
         {
            valid_slopes = (price_slope > min_slope_threshold) && (rsi_slope < -min_slope_threshold);
            if(!valid_slopes && ShowDivergenceValidation)
            {
               PrintControlledLog("VENDA REJEITADA - Slopes incorretos | Pre√ßo: " + DoubleToString(price_slope, 6) + 
                                " | RSI: " + DoubleToString(rsi_slope, 3) + " | Necess√°rio: Pre√ßo‚ÜóÔ∏è + RSI‚ÜòÔ∏è");
               return -1;
            }
         }
         
         if(IsRealDivergence(price[pivot], price[current], rsi_raw[pivot], rsi_raw[current], is_bullish))
         {
            if(IsValidRSISequence(current, is_bullish))
            {
               if(HasMinimumLineSlope(price[pivot], price[current], rsi_raw[pivot], rsi_raw[current], current - pivot, is_bullish))
               {
                  bool cleanLine = true;
                  if(RequireCleanLine || UseCleanerLines)
                     cleanLine = IsCleanDivergenceLine(price, rsi_raw, pivot, current, is_bullish);
                  
                  if(cleanLine && pivotsFound)
                  {
                     if(CheckSignificance(price[pivot], price[current], rsi_raw[pivot], rsi_raw[current], is_bullish, DivergenceMode))
                     {
                        if(IsValidTrendContext(price, pivot, current, is_bullish))
                        {
                           if(!CheckRSIQuality(rsi_raw, pivot, current, is_bullish))
                           {
                              PrintControlledLog("RSI QUALIDADE REJEITADA - Problemas de tra√ßado detectados");
                              return -1;
                           }
                           
                           double quality_score = CalculateDivergenceScore(price[pivot], price[current], 
                                                                          rsi_raw[pivot], rsi_raw[current],
                                                                          pivot, current, tick_volume, is_bullish);
                           
                           double required_score = is_bullish ? (MinQualityScore * 1.2) : (MinQualityScore * 1.1);
                           
                           if(quality_score >= required_score)
                           {
                              string divType = is_bullish ? "BULLISH" : "BEARISH";
                              PrintControlledLog("DIVERG√äNCIA " + divType + " RIGOROSA na barra " + (string)current + " | Score: " + DoubleToString(quality_score, 1));
                              
                              return pivot;
                           }
                        }
                     }
                  }
               }
            }
         }
      }
   }
   
   return -1;
}

bool CheckVolumeConfirmationEnhanced(bool is_buy, const double &open[], const double &close[], 
                                    const double &price[], const long &tick_volume[], int start, int end) 
{
   if(!UseEnhancedVolumeAnalysis)
   {
      double volumeChange = GetVolumeChangePercent(tick_volume, start, end);
      bool vol_confirmed = (volumeChange >= Volume_Divergence_Min);
      
      if(ShowVolumeDebugOnChart)
      {
         string check = vol_confirmed ? "‚úì" : "‚úó";
         string text = check + "Vol:" + DoubleToString(volumeChange, 1) + "%";
         color textColor = vol_confirmed ? clrYellow : clrDarkGray;
         CreateVolumeDebugText(iTime(NULL, 0, end), iClose(NULL, 0, end), text, textColor);
      }
      
      return vol_confirmed;
   }
   
   double volumeChange = GetVolumeChangePercent(tick_volume, start, end);
   bool original_ok = (volumeChange >= (Volume_Divergence_Min * 0.5));
   
   bool candle_direction_ok = CheckCandleDirectionVolume(open, close, tick_volume, end, is_buy);
   
   bool institutional_ok = CheckInstitutionalVolumeFlow(price, tick_volume, start, end, is_buy);
   
   int passed_criteria = 0;
   if(original_ok) passed_criteria++;
   if(candle_direction_ok) passed_criteria++;
   if(institutional_ok) passed_criteria++;
   
   bool enhanced_confirmed = (passed_criteria >= 1);
   
   if(enhanced_confirmed) enhancedVolumeUsed++;
   
   return enhanced_confirmed;
}

//+------------------------------------------------------------------+
//| ‚ö° FUN√á√ïES CORRIGIDAS: Para funcionar em Backtest Visual        |
//+------------------------------------------------------------------+

void CreateStar(datetime time, double price, bool isBuy) 
{ 
   starCounter++; 
   string starName = "RSI_Volume_Star_" + (string)starCounter + (string)TimeCurrent(); 
   
   if(ObjectCreate(0, starName, OBJ_ARROW_CHECK, 0, time, price))
   {
      ObjectSetInteger(0, starName, OBJPROP_ARROWCODE, SYMBOL_STAR);
      ObjectSetInteger(0, starName, OBJPROP_WIDTH, 4);
      ObjectSetInteger(0, starName, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, starName, OBJPROP_HIDDEN, false);
      ObjectSetInteger(0, starName, OBJPROP_BACK, false);
      
      if(isBuy) 
         ObjectSetInteger(0, starName, OBJPROP_COLOR, clrGold);
      else 
         ObjectSetInteger(0, starName, OBJPROP_COLOR, clrMagenta);
      
      if(IsVisualMode() || IsBacktest())
      {
         ChartRedraw();
         if(IsVisualMode()) Sleep(1);
      }
   }
   
   ChartRedraw(); 
}

void CreateVolumeDebugText(datetime time, double price, string text, color textColor)
{
   if(!ShowVolumeDebugOnChart && !ShowDetailedVolumeInfo) return;
   
   if(volumeTextsCreated >= MaxVolumeTextsOnChart)
   {
      string oldObjName = "VolumeDebug_" + (string)(volumeTextsCreated - MaxVolumeTextsOnChart);
      ObjectDelete(0, oldObjName);
   }
   
   string objName = "VolumeDebug_" + (string)volumeTextsCreated + "_" + (string)time;
   volumeTextsCreated++;
   
   if(ObjectCreate(0, objName, OBJ_TEXT, 0, time, price))
   {
      ObjectSetInteger(0, objName, OBJPROP_COLOR, textColor);
      ObjectSetInteger(0, objName, OBJPROP_HIDDEN, false);
      ObjectSetInteger(0, objName, OBJPROP_BACK, false);
      
      if(StringFind(text, "‚≠ê") >= 0)
      {
         ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, 12);
         ObjectSetString(0, objName, OBJPROP_FONT, "Arial Bold");
      }
      else
      {
         ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, 8);
         ObjectSetString(0, objName, OBJPROP_FONT, "Arial");
      }
      
      ObjectSetString(0, objName, OBJPROP_TEXT, text);
      ObjectSetInteger(0, objName, OBJPROP_ANCHOR, ANCHOR_LEFT_UPPER);
      ObjectSetInteger(0, objName, OBJPROP_SELECTABLE, false);
   }
}

void CreateVolumeCircle(datetime time, double volume_value, bool is_buy)
{
   if(!ShowVolumeCircles) return;
   
   starCounter++;
   string circleName = "VolumeCircle_" + (string)starCounter + (string)TimeCurrent();
   
   if(ObjectCreate(0, circleName, OBJ_ARROW, 0, time, volume_value))
   {
      ObjectSetInteger(0, circleName, OBJPROP_ARROWCODE, 159);
      ObjectSetInteger(0, circleName, OBJPROP_WIDTH, 3);
      ObjectSetInteger(0, circleName, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, circleName, OBJPROP_HIDDEN, false);
      ObjectSetInteger(0, circleName, OBJPROP_BACK, false);
      
      if(is_buy)
         ObjectSetInteger(0, circleName, OBJPROP_COLOR, clrLimeGreen);
      else
         ObjectSetInteger(0, circleName, OBJPROP_COLOR, clrRed);
      
      if(IsVisualMode() || IsBacktest())
      {
         ChartRedraw();
         if(IsVisualMode()) Sleep(1);
      }
   }
}

void CreateRSILine(datetime time1, double rsi1, datetime time2, double rsi2, bool is_bullish) 
{ 
   lineCounter++; 
   string line_name = "div_line_rsi_" + (string)lineCounter + (string)TimeCurrent(); 
   
   if(ObjectCreate(0, line_name, OBJ_TREND, 1, time1, rsi1, time2, rsi2))
   { 
      ObjectSetInteger(0, line_name, OBJPROP_COLOR, clrYellow); 
      ObjectSetInteger(0, line_name, OBJPROP_STYLE, STYLE_SOLID); 
      ObjectSetInteger(0, line_name, OBJPROP_WIDTH, 3); 
      ObjectSetInteger(0, line_name, OBJPROP_RAY_RIGHT, false); 
      ObjectSetInteger(0, line_name, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, line_name, OBJPROP_HIDDEN, false);
      ObjectSetInteger(0, line_name, OBJPROP_BACK, false);
      
      if(IsVisualMode() || IsBacktest())
      {
         ChartRedraw();
         if(IsVisualMode()) Sleep(1);
      }
   } 
}

void CreatePriceLine(datetime time1, double price1, datetime time2, double price2, bool is_bullish) 
{ 
   lineCounter++; 
   string line_name = "div_line_price_" + (string)lineCounter + (string)TimeCurrent(); 
   
   if(ObjectCreate(0, line_name, OBJ_TREND, 0, time1, price1, time2, price2)) 
   { 
      ObjectSetInteger(0, line_name, OBJPROP_COLOR, is_bullish ? clrLimeGreen : clrRed); 
      ObjectSetInteger(0, line_name, OBJPROP_STYLE, STYLE_SOLID); 
      ObjectSetInteger(0, line_name, OBJPROP_WIDTH, 2); 
      ObjectSetInteger(0, line_name, OBJPROP_RAY_RIGHT, false); 
      ObjectSetInteger(0, line_name, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, line_name, OBJPROP_HIDDEN, false);
      ObjectSetInteger(0, line_name, OBJPROP_BACK, false);
      
      if(IsVisualMode() || IsBacktest())
      {
         ChartRedraw();
         if(IsVisualMode()) Sleep(1);
      }
   } 
}

//+------------------------------------------------------------------+
//| Initialization function REEQUILIBRADA                           |
//+------------------------------------------------------------------+
int OnInit()
{
   long currentAccount = AccountInfoInteger(ACCOUNT_LOGIN);
   datetime currentTime = TimeCurrent();
   
   bool isUniversalLicense = (StringToInteger(licenseAccount) == 0);
   bool accountValid = isUniversalLicense || (currentAccount == StringToInteger(licenseAccount));
   bool timeValid = (currentTime <= licenseExpiration);
   
   if (!accountValid || !timeValid) 
   {
      string licenseType = isUniversalLicense ? "UNIVERSAL" : "ESPEC√çFICA";
      string accountInfo = isUniversalLicense ? "Qualquer conta" : ("Conta: " + licenseAccount);
      
      Print("üîí LICEN√áA ", licenseType, " inv√°lida ou expirada!");
      Print("   üìã Configura√ß√£o: ", accountInfo);
      Print("   üóìÔ∏è Expira√ß√£o: ", TimeToString(licenseExpiration));
      Print("   üîç Conta atual: ", currentAccount);
      Print("   üïí Data atual: ", TimeToString(currentTime));
      Print("   ‚ùå Status: ", accountValid ? "Conta OK" : "Conta inv√°lida", " | ", timeValid ? "Tempo OK" : "EXPIRADO");
      
      ObjectsDeleteAll(0, "RSI_Volume_Star_");  
      ObjectsDeleteAll(0, "div_line_price_");  
      ObjectsDeleteAll(0, "div_line_rsi_");
      ObjectsDeleteAll(0, "VolumeDebug_");  
      ChartRedraw();
      
      string errorMsg = "üîí LICEN√áA " + licenseType + " " + (timeValid ? "inv√°lida!" : "EXPIRADA!");
      Comment(errorMsg);
      Alert(errorMsg);
      return INIT_FAILED;
   }
   
   string licenseType = isUniversalLicense ? "UNIVERSAL" : "ESPEC√çFICA";
   Print("‚úÖ LICEN√áA ", licenseType, " V√ÅLIDA!");
   Print("   üìã Conta: ", isUniversalLicense ? "Qualquer conta (modo universal)" : licenseAccount);
   Print("   üóìÔ∏è V√°lida at√©: ", TimeToString(licenseExpiration));

   SetIndexBuffer(0, RSIBuffer, INDICATOR_DATA);
   SetIndexBuffer(1, BuyBuffer, INDICATOR_DATA);
   SetIndexBuffer(2, SellBuffer, INDICATOR_DATA);
   SetIndexBuffer(3, RSILineBuffer, INDICATOR_DATA);
   SetIndexBuffer(4, VolumeBuffer, INDICATOR_DATA);
   SetIndexBuffer(5, VolumeAvgBuffer, INDICATOR_DATA);
   SetIndexBuffer(6, VolumeBuyConfirmBuffer, INDICATOR_DATA);
   SetIndexBuffer(7, VolumeSellConfirmBuffer, INDICATOR_DATA);
   SetIndexBuffer(8, DividerBuffer, INDICATOR_DATA);
   SetIndexBuffer(9, BuySignalConfirmedBuffer, INDICATOR_DATA);
   SetIndexBuffer(10, SellSignalConfirmedBuffer, INDICATOR_DATA);
   SetIndexBuffer(11, RawRSIBuffer, INDICATOR_CALCULATIONS);
   SetIndexBuffer(12, BuyStarBacktestBuffer, INDICATOR_DATA);
   SetIndexBuffer(13, SellStarBacktestBuffer, INDICATOR_DATA);

   PlotIndexSetInteger(1, PLOT_ARROW, 233);      
   PlotIndexSetInteger(2, PLOT_ARROW, 234);      
   PlotIndexSetInteger(1, PLOT_LINE_COLOR, clrLimeGreen);  
   PlotIndexSetInteger(2, PLOT_LINE_COLOR, clrRed);        
   PlotIndexSetInteger(6, PLOT_ARROW, 159);      
   PlotIndexSetInteger(7, PLOT_ARROW, 159);
   PlotIndexSetInteger(12, PLOT_ARROW, 159);     
   PlotIndexSetInteger(13, PLOT_ARROW, 159);
   
   PlotIndexSetDouble(1, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(2, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(3, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(6, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(7, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(9, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(10, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(12, PLOT_EMPTY_VALUE, 0);
   PlotIndexSetDouble(13, PLOT_EMPTY_VALUE, 0);

   // ‚ö° CORRE√á√ÉO CR√çTICA: RSI Handle com valida√ß√£o refor√ßada
   RSIHandle = iRSI(NULL, NULL, RSI_Period, RSI_Applied);
   if(RSIHandle == INVALID_HANDLE) 
   { 
      Print("‚ùå ERRO CR√çTICO: Falha ao criar RSI Handle!");
      return INIT_FAILED; 
   }
   
   // ‚ö° NOVO: Inicializar sistema de ressuscita√ß√£o
   indicatorAlive = true;
   lastProcessTime = TimeCurrent();
   forceUpdateCounter = 0;
   
   string mode_name = "";
   switch(DivergenceMode)
   {
      case MODE_SENSITIVE: mode_name = "SENSITIVE"; break;
      case MODE_BALANCED: mode_name = "BALANCED"; break;
      case MODE_CONSERVATIVE: mode_name = "CONSERVATIVE"; break;
   }
   
   string volume_mode = UseEnhancedVolumeAnalysis ? "ENHANCED" : "CLASSIC";
   string backtest_suffix = IsBacktest() ? "-BACKTEST" : "-TEMPO-REAL";
   string license_suffix = isUniversalLicense ? "-UNIVERSAL" : "-ESPEC√çFICA";
   string tracing_mode = UseCleanerLines ? "TRA√áADO INTELIGENTE" : "QUALIDADE RSI";
   string pivot_mode = UseFlexiblePivots ? "PIV√îS FLEX√çVEIS" : "PIV√îS R√çGIDOS";
   string strict_mode = EnableStrictDivergenceCheck ? "RIGOROSO" : "NORMAL";
   string corrected_mode = UseCorrectedTracing ? "TRA√áADO CORRIGIDO" : "COMPATIBILIDADE";
   string alignment_mode = UseVerticalAlignment ? "ALINHAMENTO VERTICAL" : "CL√ÅSSICO";
   
   IndicatorSetString(INDICATOR_SHORTNAME, "Divergence RSI PrimeBot v2.40 " + alignment_mode + backtest_suffix + license_suffix + " [" + mode_name + "] [VOL:" + volume_mode + " " + tracing_mode + " " + pivot_mode + " " + strict_mode + " " + corrected_mode + "]");
   
   IndicatorSetInteger(INDICATOR_LEVELS, 6);
   
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 0, DIVIDER_LINE);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 0, clrNONE);
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 0, STYLE_DOT);
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 0, 1);
   
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 1, OverboughtLevel);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 1, clrRed);
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 1, STYLE_DASH);
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 1, 1);
   
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 2, 50.0);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 2, clrGray);
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 2, STYLE_DOT);
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 2, 1);
   
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 3, OversoldLevel);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 3, clrRed);
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 3, STYLE_DASH);
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 3, 1);
   
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 4, VOLUME_ZONE_MAX);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 4, clrDimGray);
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 4, STYLE_DASHDOTDOT);
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 4, 1);
   
   IndicatorSetDouble(INDICATOR_LEVELVALUE, 5, VOLUME_ZONE_MAX/2);
   IndicatorSetInteger(INDICATOR_LEVELCOLOR, 5, clrDimGray);
   IndicatorSetInteger(INDICATOR_LEVELSTYLE, 5, STYLE_DASHDOTDOT);
   IndicatorSetInteger(INDICATOR_LEVELWIDTH, 5, 1);
   
   IndicatorSetString(INDICATOR_LEVELTEXT, 0, "");
   IndicatorSetString(INDICATOR_LEVELTEXT, 1, "RSI " + DoubleToString(OverboughtLevel, 0) + " (Overbought)");
   IndicatorSetString(INDICATOR_LEVELTEXT, 2, "RSI 50 (Neutro)");
   IndicatorSetString(INDICATOR_LEVELTEXT, 3, "RSI " + DoubleToString(OversoldLevel, 0) + " (Oversold)");
   IndicatorSetString(INDICATOR_LEVELTEXT, 4, "Vol Max");
   IndicatorSetString(INDICATOR_LEVELTEXT, 5, "Vol M√©dio");
   
   if(ShowModeInfo) 
   {
      Print("üî• Divergence RSI PrimeBot v2.40 - ALINHAMENTO VERTICAL PERFEITO!");
      Print("üéØ Modo: ", mode_name, " | Volume: ", volume_mode, " | Piv√¥s: ", UseFlexiblePivots ? "FLEX√çVEIS" : "R√çGIDOS");
      Print("üî• FILTROS ATIVOS: Qualidade ", MinQualityScore, " | Dist√¢ncia ", MinDistanceBetweenPivots, " | Tempo ", MinBarsBetweenSignals);
      Print("üî• VALIDA√á√ÉO CONTEXTO: ", RequireTrendContext ? "ATIVA" : "DESATIVA", " | Linha Limpa: ", RequireCleanLine ? "ATIVA" : "DESATIVA");
      Print("‚ö° v2.40 ALINHAMENTO: ", UseVerticalAlignment ? "VERTICAL PERFEITO" : "CL√ÅSSICO", " | Janela extremo: ¬±", ExtremeLookback, " barras");
      Print("‚ö° CORRE√á√ÉO PRINCIPAL: Tra√ßados sempre nas MESMAS barras (alinhamento vertical)");
      Print("‚ö° CORRE√á√ÉO TEMPO REAL: Sistema de ressuscita√ß√£o autom√°tica ativado");
      Print("‚ö° CORRE√á√ÉO RSI HANDLE: Valida√ß√£o refor√ßada para prevenir falhas");
      Print("üéØ EXTREMOS REAIS: Conecta extremos verdadeiros com alinhamento perfeito");
      Print("üî• FUNCIONAMENTO: OnCalculate for√ßado a executar em tempo real");
      Print("üî• RESULTADO ESPERADO: Linhas perfeitamente alinhadas verticalmente!");
   }
   
   return INIT_SUCCEEDED;
}

void OnDeinit(const int reason) 
{ 
   if(RSIHandle != INVALID_HANDLE) IndicatorRelease(RSIHandle); 
   ObjectsDeleteAll(0, "RSI_Volume_Star_"); 
   ObjectsDeleteAll(0, "div_line_price_"); 
   ObjectsDeleteAll(0, "div_line_rsi_");
   ObjectsDeleteAll(0, "VolumeDebug_");
   ObjectsDeleteAll(0, "VolumeCircle_");
   
   if(ShowDebugInfo) 
   {
      Print("üìä ESTAT√çSTICAS v2.40 ALINHAMENTO VERTICAL:");
      Print("   üéØ Diverg√™ncias: ", divergencesDetected, " | Estrelas: ", signalsConfirmed, " | Enhanced: ", enhancedVolumeUsed);
      Print("   ‚úÖ Valida√ß√£o Rigorosa: ", strictValidationPassed, " passou | ", strictValidationFailed, " falhou");
      Print("   üö´ Rejei√ß√µes: ", divergenceRejections, " diverg√™ncia | ", cleanLineRejections, " linha cortada");
      Print("   üìù Textos criados: ", volumeTextsCreated, " | Tra√ßado corrigido: ", correctedTracingUsed);
      Print("   üéØ ALINHAMENTO VERTICAL: ", alignedTracingUsed, " tra√ßados perfeitamente alinhados");
      Print("   ‚ö° RESSUSCITA√á√ïES: ", forceUpdateCounter, " updates for√ßados");
      Print("   ‚ö° CORRE√á√ÉO APLICADA: Alinhamento vertical perfeito + Sistema ressuscita√ß√£o");
      Print("   üî• RESULTADO: Linhas sempre alinhadas verticalmente!");
   }
}

//+------------------------------------------------------------------+
//| ‚ö° FUN√á√ÉO PRINCIPAL v2.40: OnCalculate com ALINHAMENTO VERTICAL |
//+------------------------------------------------------------------+
int OnCalculate(const int rates_total, const int prev_calculated, const datetime &time[], 
                const double &open[], const double &high[], const double &low[], 
                const double &close[], const long &tick_volume[], const long &volume[], 
                const int &spread[])
{
   // ‚ö° LOG IMEDIATO: Verificar se OnCalculate est√° sendo chamado
   static int oncalculate_calls = 0;
   oncalculate_calls++;
   
   if(!IsBacktest() && ShowDebugInfo && (oncalculate_calls % 50 == 1))
   {
      Print("üîÑ OnCalculate EXECUTANDO #", oncalculate_calls, " | rates_total=", rates_total, " | prev_calculated=", prev_calculated);
   }
   
   // ‚ö° VALIDA√á√ÉO CR√çTICA: Garantir dados m√≠nimos
   if(rates_total < RSI_Period + 10) 
   {
      if(ShowDebugInfo && !IsBacktest()) 
         Print("‚ö†Ô∏è DADOS INSUFICIENTES: rates_total=", rates_total, " | Necess√°rio: ", RSI_Period + 10);
      return 0;
   }
   
   // ‚ö° SISTEMA DE RESSUSCITA√á√ÉO: For√ßar execu√ß√£o em tempo real
   ForceIndicatorUpdate();
   
   // ‚ö° CORRE√á√ÉO CR√çTICA: RSI Handle com m√∫ltiplas tentativas
   int rsi_copied = 0;
   int attempts = 0;
   
   do {
      rsi_copied = CopyBuffer(RSIHandle, 0, 0, rates_total, RawRSIBuffer);
      attempts++;
      
      if(rsi_copied <= 0) 
      {
         if(!IsBacktest() && ShowDebugInfo)
            Print("‚ö†Ô∏è RSI TENTATIVA ", attempts, " FALHOU - rsi_copied=", rsi_copied);
         
         if(attempts == 1) Sleep(10);
         else if(attempts == 2) Sleep(50);
         else break;
      }
   } while(rsi_copied <= 0 && attempts < 3);
   
   // ‚ö° VERIFICA√á√ÉO FINAL: Se RSI ainda n√£o foi copiado, abortar
   if(rsi_copied <= 0)
   {
      if(ShowDebugInfo && !IsBacktest()) 
         Print("‚ùå ERRO CR√çTICO RSI: Falha ap√≥s ", attempts, " tentativas | Handle=", RSIHandle);
      return prev_calculated;
   }
   
   if(ShowDebugInfo && !IsBacktest() && attempts > 1)
   {
      Print("‚úÖ RSI RECUPERADO: Sucesso na tentativa ", attempts, " - Copiados ", rsi_copied, " valores");
   }
   
   if(prev_calculated == 0) 
   {
      g_max_volume = 1;
      divergencesDetected = 0;
      signalsConfirmed = 0;
      signalsFiltered = 0;
      qualityFiltered = 0;
      contextFiltered = 0;
      mixedTypeFiltered = 0;
      realDivFiltered = 0;
      cleanLineFiltered = 0;
      enhancedVolumeUsed = 0;
      volumeTextsCreated = 0;
      
      strictValidationPassed = 0;
      strictValidationFailed = 0;
      cleanLineRejections = 0;
      divergenceRejections = 0;
      
      correctedTracingUsed = 0;
      correctLinesTraced = 0;
      alignedTracingUsed = 0;
      
      lastBullishPivotBar = -1;
      lastBearishPivotBar = -1;
      consecutiveBullishPivots = 0;
      consecutiveBearishPivots = 0;
      
      // ‚ö° RESET SISTEMA RESSUSCITA√á√ÉO
      lastProcessTime = TimeCurrent();
      forceUpdateCounter = 0;
      indicatorAlive = true;
   }
   
   // ‚ö° CORRE√á√ÉO v2.3.7: Usar sistema de processamento funcional
   int start_calc = (prev_calculated == 0) ? 0 : prev_calculated - 1;
   
   // ‚úÖ CORRE√á√ÉO: Atualizar buffers mantendo escala 0-100 para n√∫meros corretos
   for(int i = start_calc; i < rates_total; i++)
   {
      if(tick_volume[i] > g_max_volume) g_max_volume = tick_volume[i];
      
      if(RawRSIBuffer[i] <= 30.0)
      {
         RSIBuffer[i] = 30.0 + (RawRSIBuffer[i] / 30.0) * 5.0;
      }
      else
      {
         RSIBuffer[i] = 35.0 + ((RawRSIBuffer[i] - 30.0) / 70.0) * 65.0;
      }
      
      DividerBuffer[i] = DIVIDER_LINE;
      VolumeBuffer[i] = ScaleVolumeValue(tick_volume[i], g_max_volume);
      
      if(i >= Volume_Period) 
      { 
         long sum_vol = 0; 
         for(int j = 0; j < Volume_Period; j++) 
            sum_vol += tick_volume[i-j]; 
         VolumeAvgBuffer[i] = ScaleVolumeValue(sum_vol/Volume_Period, g_max_volume); 
      }
   }
   
   // ‚ö° CORRE√á√ÉO v2.3.7: Limite de processamento funcional
   int limit = prev_calculated == 0 ? RSI_Period + DivergenceLookback : prev_calculated - 1;
   
   // ‚ö° CORRE√á√ÉO v2.3.7: Controle de processamento tempo real
   int max_process = rates_total - (IsBacktest() ? 1 : 0);
   
   // ‚ö° FOR√áAR PROCESSAMENTO DA BARRA ATUAL EM TEMPO REAL
   if(!IsBacktest() && max_process > 0)
      max_process = rates_total; // Garantir que processa at√© a barra atual
   
   // üî• LOOP PRINCIPAL CORRIGIDO - TEMPO REAL + BACKTEST
   for(int i = limit; i < max_process; i++)
   {
      // Limpar buffers
      BuyBuffer[i] = 0; 
      SellBuffer[i] = 0;
      VolumeBuyConfirmBuffer[i] = 0; 
      VolumeSellConfirmBuffer[i] = 0;
      BuySignalConfirmedBuffer[i] = 0; 
      SellSignalConfirmedBuffer[i] = 0;
      BuyStarBacktestBuffer[i] = 0; 
      SellStarBacktestBuffer[i] = 0;
      
      if(i < RSI_Period || RawRSIBuffer[i] == 0) continue;
      
      // ===== üî• DETEC√á√ÉO DE COMPRA - ALINHAMENTO VERTICAL v2.40 =====
      int buy_pivot = CheckClassicDivergence(low, RawRSIBuffer, tick_volume, open, close, i, true);
      if(buy_pivot > 0)
      {
         divergencesDetected++;
         BuyBuffer[i] = RSIBuffer[i] - 3.0;
         
         // ‚ö° LOG TEMPO REAL: Sempre mostrar quando detectar
         if(!IsBacktest() && ShowDebugInfo)
         {
            Print("üî• COMPRA DETECTADA TEMPO REAL - Barra ", i, " | RSI: ", DoubleToString(RawRSIBuffer[i], 1));
         }
         
         // üî• v2.40: Usar alinhamento vertical perfeito
         AlignedExtremes aligned_extremes;
         
         if(UseVerticalAlignment)
         {
            aligned_extremes = FindAlignedExtremes(low, RawRSIBuffer, i, DivergenceLookback, true);
            
            if(!aligned_extremes.valid)
            {
               if(ShowDivergenceValidation)
                  PrintControlledLog("COMPRA REJEITADA - Extremos alinhados n√£o encontrados");
               continue;
            }
            
            // Verificar qualidade da diverg√™ncia
            if(!CheckRSIQuality(RawRSIBuffer, aligned_extremes.bar_past, aligned_extremes.bar_current, true))
            {
               if(ShowDivergenceValidation)
                  PrintControlledLog("COMPRA REJEITADA - Qualidade RSI insuficiente");
               continue;
            }
            
            // Tra√ßar linhas ALINHADAS VERTICALMENTE
            CreateRSILine(time[aligned_extremes.bar_past], RSIBuffer[aligned_extremes.bar_past], 
                         time[aligned_extremes.bar_current], RSIBuffer[aligned_extremes.bar_current], true);
            
            CreatePriceLine(time[aligned_extremes.bar_past], aligned_extremes.price_past, 
                           time[aligned_extremes.bar_current], aligned_extremes.price_current, true);
            
            correctLinesTraced++;
            
            if(ShowDivergenceValidation)
            {
               PrintControlledLog("COMPRA ALINHADA - Barras: " + (string)aligned_extremes.bar_past + "‚Üí" + (string)aligned_extremes.bar_current + 
                                " | Pre√ßo: " + DoubleToString(aligned_extremes.price_past, 5) + "‚Üí" + DoubleToString(aligned_extremes.price_current, 5) + 
                                " | RSI: " + DoubleToString(aligned_extremes.rsi_past, 1) + "‚Üí" + DoubleToString(aligned_extremes.rsi_current, 1));
            }
         }
         else
         {
            // Modo cl√°ssico (v2.38)
            RSIPivots rsi_pivots = FindRSIPivotsStrict(RawRSIBuffer, buy_pivot, i, true, 
                                                      low[buy_pivot], low[i]);
            
            if(!rsi_pivots.valid)
            {
               if(ShowDivergenceValidation)
                  PrintControlledLog("COMPRA REJEITADA - Tra√ßado inv√°lido ou n√£o √© diverg√™ncia real");
               continue;
            }
            
            bool price_line_clean = ValidateLineDoesNotCutPivots(low, rsi_pivots.price_pivot_past, rsi_pivots.price_pivot_current, true, 4.0);
            
            if(!price_line_clean)
            {
               if(ShowDivergenceValidation)
                  PrintControlledLog("LINHA PRE√áO REJEITADA - Corta piv√¥s intermedi√°rios");
               continue;
            }
            
            correctLinesTraced++;
            
            CreateRSILine(time[rsi_pivots.rsi_pivot_past], RSIBuffer[rsi_pivots.rsi_pivot_past], 
                         time[rsi_pivots.rsi_pivot_current], RSIBuffer[rsi_pivots.rsi_pivot_current], true);
            
            CreatePriceLine(time[rsi_pivots.price_pivot_past], low[rsi_pivots.price_pivot_past], 
                           time[rsi_pivots.price_pivot_current], low[rsi_pivots.price_pivot_current], true);
         }
         
         // Volume debug
         if(ShowVolumeDebugOnChart || ShowDetailedVolumeInfo)
         {
            double volumeChangePercent = GetVolumeChangePercent(tick_volume, buy_pivot, i);
            bool volumeOK = (volumeChangePercent >= Volume_Divergence_Min);
            string volumeText = (volumeOK ? "‚úì" : "‚úó") + "Vol:" + DoubleToString(volumeChangePercent, 1) + "%";
            CreateVolumeDebugText(time[i], close[i] - SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 30, volumeText, volumeOK ? clrYellow : clrGray);
         }
         
         // ===== üî• ESTRELA DOURADA COM VALIDA√á√ÉO DE CONTEXTO =====
         bool volumeEnhancedOK = CheckVolumeConfirmationEnhanced(true, open, close, low, tick_volume, buy_pivot, i);
         bool candleContextOK = IsValidCandleContext(open, close, high, low, i, true);
         bool timingOK = IsValidConfirmationTiming(open, close, high, low, i, true);
         
         if(volumeEnhancedOK && candleContextOK && timingOK && (i - lastBuySignalBar > MinBarsBetweenSignals))
         {
            lastBuySignalBar = i;
            signalsConfirmed++;
            
            if(EnableSignalsForEA) BuySignalConfirmedBuffer[i] = 1.0;
            BuyStarBacktestBuffer[i] = high[i];
            
            double confirmLevel = MathMin(VolumeAvgBuffer[i] + 3, VOLUME_ZONE_MAX - 1);
            VolumeBuyConfirmBuffer[i] = confirmLevel;
            
            if(ShowStarsOnChart) 
            {
               CreateStar(time[i], low[i] - SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 15, true);
               
               if(IsBacktest())
               {
                  BuyStarBacktestBuffer[i] = RSIBuffer[i] - 5.0;
               }
            }
            
            if(ShowVolumeDebugOnChart || (ShowDetailedVolumeInfo && ShowOnlyConfirmedStars))
            {
               CreateVolumeDebugText(time[i], high[i] + SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 120, 
                                   "‚≠êCOMPRA CONFIRMADA‚≠ê", clrGold);
            }
            
            if(ShowVolumeCircles)
            {
               CreateVolumeCircle(time[i], VolumeBuffer[i], true);
            }
            
            // ‚ö° LOG SEMPRE EM TEMPO REAL
            if(!IsBacktest())
            {
               Print("‚≠ê ESTRELA COMPRA CONFIRMADA - Barra ", i, " | Tempo: ", TimeToString(time[i]), " | RSI: ", DoubleToString(RawRSIBuffer[i], 1));
            }
            else
            {
               PrintControlledLog("ESTRELA COMPRA confirmada na barra " + (string)i + " (COMPLETO)");
            }
         }
      }
      
      // ===== üî• DETEC√á√ÉO DE VENDA - ALINHAMENTO VERTICAL v2.40 =====
      int sell_pivot = CheckClassicDivergence(high, RawRSIBuffer, tick_volume, open, close, i, false);
      if(sell_pivot > 0)
      {
         divergencesDetected++;
         SellBuffer[i] = RSIBuffer[i] + 3.0;
         
         // ‚ö° LOG TEMPO REAL: Sempre mostrar quando detectar
         if(!IsBacktest() && ShowDebugInfo)
         {
            Print("üî• VENDA DETECTADA TEMPO REAL - Barra ", i, " | RSI: ", DoubleToString(RawRSIBuffer[i], 1));
         }
         
         // üî• v2.40: Usar alinhamento vertical perfeito
         AlignedExtremes aligned_extremes;
         
         if(UseVerticalAlignment)
         {
            aligned_extremes = FindAlignedExtremes(high, RawRSIBuffer, i, DivergenceLookback, false);
            
            if(!aligned_extremes.valid)
            {
               if(ShowDivergenceValidation)
                  PrintControlledLog("VENDA REJEITADA - Extremos alinhados n√£o encontrados");
               continue;
            }
            
            // Verificar qualidade da diverg√™ncia
            if(!CheckRSIQuality(RawRSIBuffer, aligned_extremes.bar_past, aligned_extremes.bar_current, false))
            {
               if(ShowDivergenceValidation)
                  PrintControlledLog("VENDA REJEITADA - Qualidade RSI insuficiente");
               continue;
            }
            
            // Tra√ßar linhas ALINHADAS VERTICALMENTE
            CreateRSILine(time[aligned_extremes.bar_past], RSIBuffer[aligned_extremes.bar_past], 
                         time[aligned_extremes.bar_current], RSIBuffer[aligned_extremes.bar_current], false);
            
            CreatePriceLine(time[aligned_extremes.bar_past], aligned_extremes.price_past, 
                           time[aligned_extremes.bar_current], aligned_extremes.price_current, false);
            
            correctLinesTraced++;
            
            if(ShowDivergenceValidation)
            {
               PrintControlledLog("VENDA ALINHADA - Barras: " + (string)aligned_extremes.bar_past + "‚Üí" + (string)aligned_extremes.bar_current + 
                                " | Pre√ßo: " + DoubleToString(aligned_extremes.price_past, 5) + "‚Üí" + DoubleToString(aligned_extremes.price_current, 5) + 
                                " | RSI: " + DoubleToString(aligned_extremes.rsi_past, 1) + "‚Üí" + DoubleToString(aligned_extremes.rsi_current, 1));
            }
         }
         else
         {
            // Modo cl√°ssico (v2.38)
            RSIPivots rsi_pivots = FindRSIPivotsStrict(RawRSIBuffer, sell_pivot, i, false, 
                                                      high[sell_pivot], high[i]);
            
            if(!rsi_pivots.valid)
            {
               if(ShowDivergenceValidation)
                  PrintControlledLog("VENDA REJEITADA - Tra√ßado inv√°lido ou n√£o √© diverg√™ncia real");
               continue;
            }
            
            bool price_line_clean = ValidateLineDoesNotCutPivots(high, rsi_pivots.price_pivot_past, rsi_pivots.price_pivot_current, false, 4.0);
            
            if(!price_line_clean)
            {
               if(ShowDivergenceValidation)
                  PrintControlledLog("LINHA PRE√áO REJEITADA - Corta piv√¥s intermedi√°rios");
               continue;
            }
            
            correctLinesTraced++;
            
            CreateRSILine(time[rsi_pivots.rsi_pivot_past], RSIBuffer[rsi_pivots.rsi_pivot_past], 
                         time[rsi_pivots.rsi_pivot_current], RSIBuffer[rsi_pivots.rsi_pivot_current], false);
            
            CreatePriceLine(time[rsi_pivots.price_pivot_past], high[rsi_pivots.price_pivot_past], 
                           time[rsi_pivots.price_pivot_current], high[rsi_pivots.price_pivot_current], false);
         }
         
         // Volume debug
         if(ShowVolumeDebugOnChart || ShowDetailedVolumeInfo)
         {
            double volumeChangePercent = GetVolumeChangePercent(tick_volume, sell_pivot, i);
            bool volumeOK = (volumeChangePercent >= Volume_Divergence_Min);
            string volumeText = (volumeOK ? "‚úì" : "‚úó") + "Vol:" + DoubleToString(volumeChangePercent, 1) + "%";
            CreateVolumeDebugText(time[i], close[i] - SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 30, volumeText, volumeOK ? clrYellow : clrGray);
         }
         
         // ===== üî• ESTRELA MAGENTA COM VALIDA√á√ÉO DE CONTEXTO =====
         bool volumeEnhancedOK = CheckVolumeConfirmationEnhanced(false, open, close, high, tick_volume, sell_pivot, i);
         bool candleContextOK = IsValidCandleContext(open, close, high, low, i, false);
         bool timingOK = IsValidConfirmationTiming(open, close, high, low, i, false);
         
         if(volumeEnhancedOK && candleContextOK && timingOK && (i - lastSellSignalBar > MinBarsBetweenSignals))
         {
            lastSellSignalBar = i;
            signalsConfirmed++;
            
            if(EnableSignalsForEA) SellSignalConfirmedBuffer[i] = 1.0;
            SellStarBacktestBuffer[i] = low[i];
            
            double confirmLevel = MathMin(VolumeAvgBuffer[i] + 3, VOLUME_ZONE_MAX - 1);
            VolumeSellConfirmBuffer[i] = confirmLevel;
            
            if(ShowStarsOnChart) 
            {
               CreateStar(time[i], high[i] + SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 15, false);
               
               if(IsBacktest())
               {
                  SellStarBacktestBuffer[i] = RSIBuffer[i] + 5.0;
               }
            }
            
            if(ShowVolumeDebugOnChart || (ShowDetailedVolumeInfo && ShowOnlyConfirmedStars))
            {
               CreateVolumeDebugText(time[i], high[i] + SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 120, 
                                   "‚≠êVENDA CONFIRMADA‚≠ê", clrMagenta);
            }
            
            if(ShowVolumeCircles)
            {
               CreateVolumeCircle(time[i], VolumeBuffer[i], false);
            }
            
            // ‚ö° LOG SEMPRE EM TEMPO REAL
            if(!IsBacktest())
            {
               Print("‚≠ê ESTRELA VENDA CONFIRMADA - Barra ", i, " | Tempo: ", TimeToString(time[i]), " | RSI: ", DoubleToString(RawRSIBuffer[i], 1));
            }
            else
            {
               PrintControlledLog("ESTRELA VENDA confirmada na barra " + (string)i + " (COMPLETO)");
            }
         }
      }
   }
   
   // ‚ö° SISTEMA DE REDESENHO AGRESSIVO PARA TEMPO REAL
   if(!IsBacktest())
   {
      // ‚ö° FOR√áAR REDESENHO SEMPRE EM TEMPO REAL
      ChartRedraw();
      
      // ‚ö° LOG PERIODICO DE VIDA
      static int heartbeat_counter = 0;
      heartbeat_counter++;
      if(heartbeat_counter % 100 == 0 && ShowDebugInfo)
      {
         Print("üíì INDICADOR VIVO - Heartbeat #", heartbeat_counter, " | Barras: ", rates_total, " | Sinais: ", signalsConfirmed, " | Alinhados: ", alignedTracingUsed);
      }
   }
   else
   {
      // ‚ö° SISTEMA SIMPLIFICADO (baseado em v2.3.7 funcional) PARA BACKTEST
      static int last_signals_count = 0;
      if(signalsConfirmed != last_signals_count)
      {
         ChartRedraw();
         last_signals_count = signalsConfirmed;
      }
   }
   
   // ‚ö° FOR√áAR REDESENHO EM BACKTEST VISUAL
   if(IsVisualMode())
   {
      static int last_processed = 0;
      if(rates_total != last_processed)
      {
         ChartRedraw();
         last_processed = rates_total;
      }
   }
   
   // ‚ö° LOG FINAL (apenas primeira execu√ß√£o ou mudan√ßas significativas)
   if(ShowDebugInfo && (prev_calculated == 0 || (!IsBacktest() && signalsConfirmed > 0)))
   {
      if(prev_calculated == 0)
      {
         Print("‚úÖ INICIALIZA√á√ÉO COMPLETA v2.40: ", rates_total, " barras processadas");
         Print("   üéØ Diverg√™ncias: ", divergencesDetected, " | Estrelas: ", signalsConfirmed, " | Enhanced: ", enhancedVolumeUsed);
         Print("   ‚úÖ Valida√ß√£o: ", strictValidationPassed, " passou | ", strictValidationFailed, " falhou");
         Print("   üö´ Rejei√ß√µes: ", divergenceRejections, " diverg√™ncia | ", cleanLineRejections, " linha cortada");
         Print("   üî• TRA√áADO CORRIGIDO: ", correctedTracingUsed, " usado | ", correctLinesTraced, " linhas corretas");
         Print("   üéØ ALINHAMENTO VERTICAL: ", alignedTracingUsed, " tra√ßados perfeitamente alinhados");
         Print("   ‚ö° CORRE√á√ïES APLICADAS:");
         Print("      - Alinhamento vertical perfeito das linhas");
         Print("      - Tra√ßados sempre nas MESMAS barras");
         Print("      - RSI Handle com retry autom√°tico");
         Print("      - Sistema de ressuscita√ß√£o ativado");
         Print("      - Redesenho for√ßado em tempo real");
         Print("   üéØ RESULTADO: Linhas perfeitamente alinhadas verticalmente!");
      }
   }
   
   // ‚ö° LOG FINAL CADA EXECU√á√ÉO EM TEMPO REAL (para debugging)
   if(!IsBacktest() && ShowDebugInfo && (oncalculate_calls % 100 == 0))
   {
      Print("üîÑ OnCalculate FINALIZADO #", oncalculate_calls, " | Retornando: ", rates_total);
   }
   
   return rates_total;
}
//+------------------------------------------------------------------+
